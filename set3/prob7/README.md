## Problem <problem 20>.<Break fixed-nonce CTR statistically>
题目描述：
在文件中找到相似的base64编码的明文格式，就像最开始那样处理，但是解决的问题不同
不是对已知明文进行点猜测，而是以与重复键相同的方式处理密文集合 - 键异或。
显然，CTR加密似乎不同于重复密钥XOR，但是对于固定的随机数，它们实际上是相同的事情
要利用这一点：获取密文集合并将其截断到公共长度（最小密文的长度将工作）。
解密密文的结果连接，就好像重复密钥XOR，密钥大小为XOR的密文长度。

### 0x01
重新考虑进行反解的方式。

### 0x02
代码中出错的问题
第一步是反解的时候过于麻烦，第二个是没有确定好改变的位数并且对修改的位数进行改变。
void reverse(int *mt1,int len){//经过reverse的函数，实现将mt1[]函数变成mt0[]函数 ,关键在于reverse函数 ，这个函数实现，所有问题都解决！ 
	int i,y,re;
	int part1;//最低的最后一位。
	int part2;//用来存放倒数第二位到倒数第15位。  
	for(i=0;i<len;i++){
	/*第一重值恢复完毕.第一部分的分析比较简单，因为直接是偏移了18位，所以直接再偏移18位就能得到正确的值。*/
	mt1[i]=(mt1[i]>>18)^mt1[i];
	/*第二重的分析也比较的恶心， */ 
	part1=mt1[i]<<15;//得到保存下来的低16位的值。
	//强行消掉part1的最高位。
	part1=part1&0xefffffff; 
	//part3部分是最高的一位，进行假设，正确的一个就是这个地方要恢复值。
	part2=part1&0xefc60000^mt1[i];//先假定最高的一位是1，那么，回复出来了y<<15的值；这样part3应该是最初的y值。 
	if((((part2<<15)&0xefc60000)^part2)==mt1[i]){
		mt1[i]=part2;
	}else{
		mt1[i]=(part1|0x80000000)&0xefc60000^mt1[i];
	}
	/*第三部分：恢复值得方法真的是没有办法了，只能得到其中的14位，还有18位不能得到，只能用穷举的办法取得值了*/
	part1=(mt1[i]<<7)&0x00003fff;
	//这个地方还是很有问题的，不是在part的基础上进行增加，而是设置一个 
	for(part1;part1<=0xffffffff;part1=part1+0x1){
		printf("%x",part1);
		part2=(part1&0x9d2c5680)^mt1[i];
		if((part2^((part2<<7)&0x9d2c5680))==mt1[i]){
			break;
		}
	}
	mt1[i]=part2;
	part1=(mt1[i]>>11)&0xfffffff8;//将最后三位清空便于比较。
	for(part1;part1<=(part1|0x0000000f);part1++){
		part2=part1^mt1[i];
		if((part2^(part2>>11))==mt1[i]){
			break;
		}
	} 
 	mt1[i]=part2;
    }
	/*第二重值恢复完毕*/
	/*第三种表示，这个恢复实在是太麻烦了，只能采用暴力的办法了*/
### 0x03 Reference
